// Generated by dts-bundle-generator v8.0.1

import { NextFunction, Request, Response } from 'express';
import { Document } from 'mongoose';
import winston from 'winston';

export type LogType = "info" | "warn" | "error" | "fatal";
/**
 * A universal logger class.
 */
export declare class Logger {
	/**
	 * The path to the logs folder.
	 */
	logsPath: string;
	/**
	 * The logger objects for each log level.
	 */
	loggers: Record<LogType, winston.Logger>;
	constructor(logsPath: string);
	/**
	 * Logs a message to both the console and the logger.
	 * @param message The message to log.
	 * @param type The type of the message.
	 */
	log(message: string, type?: LogType): void;
}
export declare enum PunishmentType {
	Warn = 0,
	Mute = 1,
	Kick = 2,
	Ban = 3
}
/**
 * A function to convert punishment types into strings.
 * The type of punishment.
 * @returns The string representation of the punishment type.
 */
export declare function PunishmentTypeToName(type: PunishmentType): "Warn" | "Mute" | "Kick" | "Ban";
export interface IDBPunishment extends DBPunishment, Document {
}
export declare const PunishmentConfigSchema: mongoose.Schema<IDBPunishment, mongoose.Model<IDBPunishment, any, any, any, mongoose.Document<unknown, any, IDBPunishment> & Omit<IDBPunishment & {
	_id: mongoose.Types.ObjectId;
}, never>, any>, {}, {}, {}, {}, mongoose.DefaultSchemaOptions, IDBPunishment, mongoose.Document<unknown, {}, mongoose.FlatRecord<IDBPunishment>> & Omit<mongoose.FlatRecord<IDBPunishment> & {
	_id: mongoose.Types.ObjectId;
}, never>>;
export declare enum TicketType {
	Private = -1,
	General = 0,
	MemberReport = 1,
	ModReport = 2,
	HeadModReport = 3
}
export interface IDBTicket extends DBTicket, Document {
}
export declare const TicketConfigSchema: mongoose.Schema<IDBTicket, mongoose.Model<IDBTicket, any, any, any, mongoose.Document<unknown, any, IDBTicket> & Omit<IDBTicket & {
	_id: mongoose.Types.ObjectId;
}, never>, any>, {}, {}, {}, {}, mongoose.DefaultSchemaOptions, IDBTicket, mongoose.Document<unknown, {}, mongoose.FlatRecord<IDBTicket>> & Omit<mongoose.FlatRecord<IDBTicket> & {
	_id: mongoose.Types.ObjectId;
}, never>>;
export interface DBUserSettings {
	/**
	 * Can the user receive game invites (chess, tictactoe, etc.)
	 */
	allowGameInvites: boolean;
	/**
	 * Is this the first time of the user using the chatbot?
	 */
	chatbotFirstTime: boolean;
}
export interface DBUser {
	/**
	 * The user's id
	 */
	userId: string;
	/**
	 * The first time the user joined the server (in seconds)
	 */
	firstjoined: number;
	/**
	 * The last time the user joined the server (in seconds)
	 */
	lastjoined: number;
	/**
	 * If the user is in the guild
	 */
	inguild: boolean;
	/**
	 * If the user is muted
	 */
	muted: boolean;
	/**
	 * If the user is banned
	 */
	banned: boolean;
	/**
	 * The user's mod level
	 */
	mod: number;
	/**
	 * If the user is banned from tickets (currently unused)
	 */
	ticketban: boolean;
	/**
	 * The user's settings
	 */
	settings: DBUserSettings;
}
export interface DBPunishment {
	/**
	 * The punishment's id
	 */
	punishmentId: string;
	/**
	 * The user's id who was punished
	 */
	user: string;
	/**
	 * The moderator's id who punished the user
	 */
	mod: string;
	/**
	 * The type of punishment
	 */
	type: PunishmentType;
	/**
	 * The reason of the punishment
	 */
	reason: string;
	/**
	 * The time the punishment was created (in seconds)
	 */
	at: number;
	/**
	 * The time the punishment will end (in seconds)
	 */
	until: number;
	/**
	 * If the punishment is active
	 */
	active: boolean;
	/**
	 * If the punishment was created by automod
	 */
	automated: boolean;
	/**
	 * If the punishment was appealed
	 */
	appealed: boolean;
}
export interface DBGiveaway {
	/**
	 * The giveaway's id
	 */
	giveawayId: string;
	/**
	 * The giveaway's message id
	 */
	message: string;
	/**
	 * The giveaway's channel id
	 */
	channel: string;
	/**
	 * The user's id who created the giveaway
	 */
	host: string;
	/**
	 * The giveaway's name
	 */
	name: string;
	/**
	 * The time the giveaway was created (in seconds)
	 */
	start: number;
	/**
	 * The time the giveaway will end (in seconds)
	 */
	end: number;
	/**
	 * If the giveaway has ended
	 */
	ended: boolean;
	/**
	 * The number of winners
	 */
	winners: number;
	/**
	 * The giveaway's filter
	 */
	filter: GiveawayFilter;
}
export interface GiveawayFilter {
	/**
	 * Are nitro users allowed to be winners?
	 */
	nitro: boolean;
}
export interface DBLevel {
	/**
	 * The user's id
	 */
	userId: string;
	/**
	 * The user's xp
	 */
	xp: number;
}
export interface DBTicket {
	/**
	 * The ticket's id
	 */
	ticketId: string;
	/**
	 * The channel's id that serves as the ticket
	 */
	channel: string;
	/**
	 * The user's id who created the ticket
	 */
	creator: string;
	/**
	 * The moderator's id who claimed the ticket
	 */
	mod: string;
	/**
	 * The minimum mod level required to claim the ticket
	 */
	modlevel: number;
	/**
	 * The mod level this ticket is waiting for (0 if not waiting for a mod)
	 */
	waitingfor: number;
	/**
	 * The type of ticket
	 */
	type: TicketType;
	/**
	 * The users of the ticket who were manually added
	 */
	users: Map<string, string>;
	/**
	 * If the ticket is closed
	 */
	closed: boolean;
	/**
	 * The time the ticket was closed (in seconds)
	 */
	closedat: number;
}
export interface DBTictactoe {
	/**
	 * The user's id
	 */
	user: string;
	/**
	 * The user's played games
	 */
	gamesPlayed: number;
	/**
	 * The user's won games
	 */
	gamesWon: number;
	/**
	 * The user's lost games
	 */
	gamesLost: number;
	/**
	 * The user's elo
	 */
	elo: number;
}
export interface IDBGiveaway extends DBGiveaway, Document {
}
export declare const GiveawayConfigSchema: mongoose.Schema<IDBGiveaway, mongoose.Model<IDBGiveaway, any, any, any, mongoose.Document<unknown, any, IDBGiveaway> & Omit<IDBGiveaway & {
	_id: mongoose.Types.ObjectId;
}, never>, any>, {}, {}, {}, {}, mongoose.DefaultSchemaOptions, IDBGiveaway, mongoose.Document<unknown, {}, mongoose.FlatRecord<IDBGiveaway>> & Omit<mongoose.FlatRecord<IDBGiveaway> & {
	_id: mongoose.Types.ObjectId;
}, never>>;
export interface IDBLevel extends DBLevel, Document {
}
export declare const LevelConfigSchema: mongoose.Schema<IDBLevel, mongoose.Model<IDBLevel, any, any, any, mongoose.Document<unknown, any, IDBLevel> & Omit<IDBLevel & {
	_id: mongoose.Types.ObjectId;
}, never>, any>, {}, {}, {}, {}, mongoose.DefaultSchemaOptions, IDBLevel, mongoose.Document<unknown, {}, mongoose.FlatRecord<IDBLevel>> & Omit<mongoose.FlatRecord<IDBLevel> & {
	_id: mongoose.Types.ObjectId;
}, never>>;
export interface IDBTictactoe extends DBTictactoe, Document {
}
export declare const TictactoeConfigSchema: mongoose.Schema<IDBTictactoe, mongoose.Model<IDBTictactoe, any, any, any, mongoose.Document<unknown, any, IDBTictactoe> & Omit<IDBTictactoe & {
	_id: mongoose.Types.ObjectId;
}, never>, any>, {}, {}, {}, {}, mongoose.DefaultSchemaOptions, IDBTictactoe, mongoose.Document<unknown, {}, mongoose.FlatRecord<IDBTictactoe>> & Omit<mongoose.FlatRecord<IDBTictactoe> & {
	_id: mongoose.Types.ObjectId;
}, never>>;
export interface IDBUser extends DBUser, Document {
}
export declare const UserConfigSchema: mongoose.Schema<IDBUser, mongoose.Model<IDBUser, any, any, any, mongoose.Document<unknown, any, IDBUser> & Omit<IDBUser & {
	_id: mongoose.Types.ObjectId;
}, never>, any>, {}, {}, {}, {}, mongoose.DefaultSchemaOptions, IDBUser, mongoose.Document<unknown, {}, mongoose.FlatRecord<IDBUser>> & Omit<mongoose.FlatRecord<IDBUser> & {
	_id: mongoose.Types.ObjectId;
}, never>>;
export type InternalMessageType = "createAppeal" | "muteUser" | "appealProcessed";
export type InternalMessageData<T extends InternalMessageType> = T extends "createAppeal" ? {
	punishmentId: string;
	reason: string;
	additional: string;
} : T extends "muteUser" ? {
	userId: string;
	mod: string;
	reason: string;
	duration: number;
} : T extends "appealProcessed" ? {
	punishmentId: string;
	status: "accepted" | "denied";
	reason: string;
} : never;
export interface InternalMessage<T extends InternalMessageType> {
	type: T;
	data: InternalMessageData<T>;
}
/**
 * Send an internal message to a http endpoint
 * @param message The message to send
 */
export declare function sendInternalMessage<T extends InternalMessageType>(privateKey: Buffer, message: InternalMessage<T>, endpoint: string): Promise<boolean>;
export interface RequestWithMessage extends Request {
	message: InternalMessage<InternalMessageType>;
}
/**
 * Express middleware to read an internal message from a request
 * @param publicKey The public key to verify the message with
 * @returns The message if it is valid, otherwise a string with the error
 */
export declare const processInternalMessage: (publicKey: Buffer) => (req: RequestWithMessage, res: Response, next: NextFunction) => Promise<Response<any, Record<string, any>>>;
export declare function isCreateAppealMessage(message: InternalMessage<InternalMessageType>): message is InternalMessage<"createAppeal">;
export declare function isMuteUserMessage(message: InternalMessage<InternalMessageType>): message is InternalMessage<"muteUser">;

export {};
import mongoose from "mongoose"
